
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Tue Mar 28 23:22:39 GFT 2017
//----------------------------------------------------

package compiler.generated;

import compiler.tipo.Tipo;
import compiler.tipo.TipoFuncao;
import compiler.Table.Simbolo;
import compiler.Table.TabelaDeSimbolos;
import java.util.*;
import main.MainTest;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Tue Mar 28 23:22:39 GFT 2017
  */
public class Parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\u0125\000\002\002\006\000\002\002\004\000\002\003" +
    "\004\000\002\236\002\000\002\003\010\000\002\015\003" +
    "\000\002\237\002\000\002\010\011\000\002\012\007\000" +
    "\002\013\005\000\002\240\002\000\002\013\005\000\002" +
    "\013\002\000\002\014\005\000\002\014\003\000\002\016" +
    "\004\000\002\016\002\000\002\020\004\000\002\020\003" +
    "\000\002\017\006\000\002\241\002\000\002\017\005\000" +
    "\002\103\004\000\002\103\002\000\002\104\004\000\002" +
    "\104\003\000\002\105\006\000\002\242\002\000\002\105" +
    "\005\000\002\106\003\000\002\106\003\000\002\106\003" +
    "\000\002\106\003\000\002\106\003\000\002\106\003\000" +
    "\002\106\003\000\002\022\004\000\002\022\002\000\002" +
    "\023\004\000\002\023\003\000\002\024\006\000\002\243" +
    "\002\000\002\024\005\000\002\004\005\000\002\004\003" +
    "\000\002\110\003\000\002\110\003\000\002\110\003\000" +
    "\002\111\003\000\002\111\003\000\002\112\005\000\002" +
    "\113\005\000\002\114\003\000\002\114\004\000\002\115" +
    "\003\000\002\115\003\000\002\115\003\000\002\115\003" +
    "\000\002\116\010\000\002\117\005\000\002\117\003\000" +
    "\002\120\003\000\002\121\003\000\002\121\003\000\002" +
    "\122\003\000\002\123\005\000\002\123\007\000\002\123" +
    "\005\000\002\124\005\000\002\124\003\000\002\125\005" +
    "\000\002\126\007\000\002\126\006\000\002\126\002\000" +
    "\002\127\005\000\002\127\003\000\002\130\005\000\002" +
    "\130\003\000\002\131\007\000\002\131\011\000\002\131" +
    "\007\000\002\132\005\000\002\132\003\000\002\133\003" +
    "\000\002\133\005\000\002\134\003\000\002\135\003\000" +
    "\002\136\005\000\002\137\003\000\002\140\005\000\002" +
    "\141\004\000\002\142\003\000\002\035\003\000\002\244" +
    "\002\000\002\035\005\000\002\026\004\000\002\026\002" +
    "\000\002\027\005\000\002\027\003\000\002\030\003\000" +
    "\002\030\003\000\002\031\005\000\002\031\005\000\002" +
    "\037\003\000\002\037\003\000\002\040\005\000\002\041" +
    "\005\000\002\041\003\000\002\042\003\000\002\042\003" +
    "\000\002\042\003\000\002\042\003\000\002\043\005\000" +
    "\002\044\006\000\002\045\003\000\002\046\003\000\002" +
    "\226\004\000\002\036\003\000\002\032\005\000\002\032" +
    "\005\000\002\032\005\000\002\033\006\000\002\245\002" +
    "\000\002\033\007\000\002\107\003\000\002\227\004\000" +
    "\002\034\003\000\002\167\005\000\002\167\003\000\002" +
    "\167\002\000\002\170\003\000\002\170\003\000\002\025" +
    "\003\000\002\206\005\000\002\171\005\000\002\171\003" +
    "\000\002\172\005\000\002\172\003\000\002\173\003\000" +
    "\002\173\003\000\002\173\003\000\002\173\003\000\002" +
    "\174\003\000\002\174\003\000\002\174\003\000\002\174" +
    "\003\000\002\174\003\000\002\174\003\000\002\174\003" +
    "\000\002\174\003\000\002\174\003\000\002\174\003\000" +
    "\002\174\002\000\002\175\006\000\002\177\006\000\002" +
    "\177\010\000\002\201\005\000\002\203\005\000\002\007" +
    "\004\000\002\006\010\000\002\214\003\000\002\151\003" +
    "\000\002\230\003\000\002\230\003\000\002\215\003\000" +
    "\002\234\005\000\002\235\004\000\002\235\003\000\002" +
    "\231\005\000\002\232\005\000\002\232\003\000\002\233" +
    "\003\000\002\233\005\000\002\233\007\000\002\205\004" +
    "\000\002\206\005\000\002\210\007\000\002\210\010\000" +
    "\002\246\002\000\002\207\007\000\002\176\006\000\002" +
    "\200\010\000\002\202\005\000\002\204\005\000\002\211" +
    "\003\000\002\212\005\000\002\212\003\000\002\213\005" +
    "\000\002\216\005\000\002\216\003\000\002\217\003\000" +
    "\002\220\003\000\002\220\005\000\002\221\003\000\002" +
    "\221\005\000\002\222\003\000\002\222\005\000\002\223" +
    "\004\000\002\223\003\000\002\224\003\000\002\224\005" +
    "\000\002\225\003\000\002\225\003\000\002\225\003\000" +
    "\002\225\003\000\002\225\005\000\002\225\004\000\002" +
    "\225\003\000\002\225\003\000\002\063\003\000\002\063" +
    "\003\000\002\063\003\000\002\063\004\000\002\064\003" +
    "\000\002\064\003\000\002\065\003\000\002\065\003\000" +
    "\002\065\003\000\002\067\006\000\002\077\005\000\002" +
    "\101\005\000\002\156\004\000\002\102\004\000\002\061" +
    "\005\000\002\061\003\000\002\062\003\000\002\047\003" +
    "\000\002\047\005\000\002\050\003\000\002\050\005\000" +
    "\002\051\003\000\002\051\005\000\002\052\004\000\002" +
    "\052\003\000\002\053\003\000\002\053\005\000\002\054" +
    "\003\000\002\054\005\000\002\054\003\000\002\054\004" +
    "\000\002\152\003\000\002\152\003\000\002\152\003\000" +
    "\002\153\003\000\002\153\003\000\002\154\003\000\002" +
    "\155\003\000\002\074\005\000\002\074\004\000\002\075" +
    "\005\000\002\075\003\000\002\076\005\000\002\076\003" +
    "\000\002\066\004\000\002\072\003\000\002\147\003\000" +
    "\002\150\003\000\002\144\003\000\002\145\003\000\002" +
    "\146\003\000\002\070\003\000\002\160\003\000\002\160" +
    "\003\000\002\160\003\000\002\161\003\000\002\161\003" +
    "\000\002\161\003\000\002\161\003\000\002\161\003\000" +
    "\002\166\003\000\002\166\003\000\002\166\003\000\002" +
    "\166\003\000\002\166\003\000\002\166\003\000\002\166" +
    "\003\000\002\143\003\000\002\021\003\000\002\021\004" +
    "\000\002\021\003\000\002\162\003\000\002\162\003\000" +
    "\002\055\003\000\002\055\003\000\002\055\003\000\002" +
    "\005\005\000\002\005\003\000\002\011\006\000\002\100" +
    "\003\000\002\100\003\000\002\060\003\000\002\164\003" +
    "\000\002\165\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u01a6\000\004\046\006\001\002\000\004\002\u01a8\001" +
    "\002\000\004\071\021\001\002\000\004\067\010\001\002" +
    "\000\004\071\uffff\001\ufffe\000\002\001\ufeed\000\004\021" +
    "\012\001\002\000\004\067\014\001\002\000\006\022\017" +
    "\074\015\001\002\000\002\001\uffd5\000\002\001\ufedd\000" +
    "\004\067\020\001\002\000\002\001\ufffd\000\002\001\uffd6" +
    "\000\002\001\ufede\000\006\003\023\041\024\001\ufff5\000" +
    "\002\001\ufff7\000\004\075\253\001\002\000\004\007\030" +
    "\001\ufff1\000\004\072\027\001\002\000\002\001\001\000" +
    "\006\003\u0181\067\010\001\002\000\004\056\033\001\uffea" +
    "\000\004\062\211\001\uffdc\000\006\003\035\067\010\001" +
    "\002\000\002\001\uffe8\000\002\001\uffe6\000\004\077\041" +
    "\001\002\000\006\003\035\067\010\001\uffeb\000\002\001" +
    "\uffe9\000\046\004\077\010\042\011\071\021\057\044\053" +
    "\047\070\051\066\053\063\066\045\067\054\075\102\102" +
    "\064\111\061\112\075\113\073\114\062\115\076\116\047" +
    "\001\002\000\002\001\ufee9\000\002\001\ufee6\000\004\076" +
    "\205\001\002\000\002\001\ufeea\000\002\001\uffc8\000\002" +
    "\001\uffe0\000\002\001\ufeec\000\002\001\uffd2\000\002\001" +
    "\uffd1\000\012\004\077\047\070\051\066\102\064\001\002" +
    "\000\004\076\ufeed\001\uffe4\000\002\001\uffd3\000\002\001" +
    "\uffe3\000\004\067\014\001\002\000\002\001\uffca\000\004" +
    "\067\010\001\002\000\002\001\uffde\000\002\001\uffe2\000" +
    "\004\043\176\001\002\000\002\001\uffd0\000\004\043\173" +
    "\001\002\000\002\001\uffd4\000\006\006\126\067\014\001" +
    "\uffb8\000\002\001\ufee8\000\004\071\021\001\002\000\002" +
    "\001\uffe1\000\002\001\uffcb\000\002\001\ufee5\000\002\001" +
    "\uffdf\000\004\105\105\001\002\000\010\067\010\075\102" +
    "\112\075\001\002\000\002\001\uffcd\000\002\001\ufee7\000" +
    "\002\001\uffc9\000\002\001\ufeeb\000\020\010\042\011\071" +
    "\021\057\066\045\067\010\075\102\112\075\001\002\000" +
    "\002\001\uffc4\000\004\076\ufee6\001\uffc2\000\006\074\015" +
    "\101\114\001\002\000\002\001\uffc5\000\002\001\uffc3\000" +
    "\020\010\042\011\071\021\057\066\045\067\010\075\102" +
    "\112\075\001\002\000\004\043\115\001\002\000\046\004" +
    "\077\010\042\011\071\021\057\044\053\047\070\051\066" +
    "\053\063\066\045\067\054\075\102\102\064\111\061\112" +
    "\075\113\073\114\062\115\076\116\047\001\002\000\002" +
    "\001\uffc1\000\002\001\uffc7\000\002\001\uffc6\000\002\001" +
    "\uffe7\000\004\027\172\001\002\000\002\001\uffbc\000\006" +
    "\027\167\071\021\001\002\000\006\073\164\074\015\001" +
    "\002\000\004\067\010\001\002\000\002\001\uffb6\000\004" +
    "\043\136\001\002\000\004\073\133\001\002\000\004\073" +
    "\uffac\001\uffab\000\004\067\010\001\002\000\002\001\uffb7" +
    "\000\002\001\uffab\000\016\010\042\011\071\066\045\067" +
    "\010\075\102\112\075\001\002\000\006\073\151\074\015" +
    "\001\002\000\002\001\uffb4\000\004\071\021\001\uffb9\000" +
    "\004\076\144\001\uffae\000\002\001\uffaf\000\016\010\042" +
    "\011\071\066\045\067\010\075\102\112\075\001\002\000" +
    "\002\001\uffad\000\016\010\042\011\071\066\045\067\010" +
    "\075\102\112\075\001\uffba\000\002\001\uffb5\000\016\010" +
    "\042\011\071\066\045\067\010\075\102\112\075\001\002" +
    "\000\004\021\152\001\002\000\006\006\126\067\014\001" +
    "\uffb8\000\004\022\162\001\002\000\006\022\155\071\021" +
    "\001\002\000\002\001\uffb3\000\006\006\126\067\014\001" +
    "\uffb8\000\004\022\161\001\002\000\002\001\uffbd\000\002" +
    "\001\uffb2\000\002\001\uffb1\000\002\001\uffb0\000\046\004" +
    "\077\010\042\011\071\021\057\044\053\047\070\051\066" +
    "\053\063\066\045\067\054\075\102\102\064\111\061\112" +
    "\075\113\073\114\062\115\076\116\047\001\002\000\002" +
    "\001\uffbb\000\006\006\126\067\014\001\uffb8\000\002\001" +
    "\uffc0\000\004\027\171\001\002\000\002\001\uffbf\000\002" +
    "\001\uffbe\000\020\010\042\011\071\021\057\066\045\067" +
    "\010\075\102\112\075\001\002\000\002\001\uffa9\000\002" +
    "\001\uffaa\000\046\004\077\010\042\011\071\021\057\044" +
    "\053\047\070\051\066\053\063\066\045\067\054\075\102" +
    "\102\064\111\061\112\075\113\073\114\062\115\076\116" +
    "\047\001\002\000\002\001\uffa8\000\002\001\uffa6\000\002" +
    "\001\uffa7\000\006\022\203\074\015\001\002\000\002\001" +
    "\uffcf\000\002\001\uffcc\000\016\010\042\011\071\066\045" +
    "\067\010\075\102\112\075\001\002\000\002\001\uffce\000" +
    "\004\071\021\001\002\000\002\001\uffe5\000\006\003\u0178" +
    "\067\014\001\002\000\006\033\223\045\216\001\uffa1\000" +
    "\002\001\uff9d\000\004\071\021\001\uff87\000\004\071\021" +
    "\001\002\000\004\067\010\001\002\000\004\071\021\001" +
    "\002\000\004\021\uffa4\001\uffa5\000\002\001\uff9f\000\002" +
    "\001\uff9e\000\004\067\010\001\002\000\002\001\ufffb\000" +
    "\004\071\021\001\002\000\006\033\223\045\216\001\uffa2" +
    "\000\002\001\uffa0\000\004\005\231\001\002\000\026\005" +
    "\231\006\242\031\252\034\266\035\257\050\243\063\267" +
    "\064\240\067\010\075\253\001\uff80\000\002\001\uff7d\000" +
    "\002\001\ufffa\000\002\001\uff76\000\002\001\uff2e\000\002" +
    "\001\uff77\000\002\001\uff6c\000\004\067\010\001\002\000" +
    "\002\001\uff71\000\032\010\042\011\071\016\307\021\311" +
    "\042\312\066\306\067\010\075\335\105\326\112\331\117" +
    "\310\120\323\001\002\000\002\001\uff4f\000\004\024\u0130" +
    "\001\002\000\002\001\uff70\000\004\024\u012d\001\002\000" +
    "\002\001\uff7f\000\002\001\uff6d\000\002\001\uff75\000\004" +
    "\067\010\001\002\000\002\001\ufffc\000\014\021\u010c\070" +
    "\uff30\072\uff30\105\uff30\111\uff30\001\uff5a\000\002\001\uff6a" +
    "\000\002\001\uff73\000\032\010\042\011\071\016\307\021" +
    "\311\042\312\066\306\067\010\075\335\105\326\112\331" +
    "\117\310\120\323\001\002\000\002\001\uff6f\000\002\001" +
    "\uff81\000\002\001\uff2f\000\002\001\uff72\000\012\070\u0119" +
    "\072\352\105\350\111\351\001\002\000\002\001\uff7a\000" +
    "\004\075\253\001\002\000\032\010\042\011\071\016\307" +
    "\021\311\042\312\066\306\067\010\075\335\105\326\112" +
    "\331\117\310\120\323\001\002\000\004\073\302\001\002" +
    "\000\002\001\uff74\000\002\001\uff78\000\002\001\uff7e\000" +
    "\002\001\uff6e\000\002\001\uff6b\000\006\027\300\071\021" +
    "\001\002\000\026\005\231\006\242\031\252\034\266\035" +
    "\257\050\243\063\267\064\240\067\010\075\253\001\uff69" +
    "\000\002\001\uff7c\000\002\001\uff82\000\024\005\231\006" +
    "\242\031\252\034\266\035\257\050\243\063\267\064\240" +
    "\067\010\001\uff69\000\002\001\uff7b\000\002\001\uff79\000" +
    "\004\021\u010c\001\uff30\000\002\001\uff10\000\026\016\307" +
    "\021\311\042\312\066\306\067\010\075\335\105\326\112" +
    "\331\117\310\120\323\001\002\000\002\001\uff32\000\032" +
    "\010\042\011\071\016\307\021\311\042\312\066\306\067" +
    "\010\075\335\105\326\112\331\117\310\120\323\001\002" +
    "\000\002\001\uff0f\000\002\001\uff3b\000\002\001\uff43\000" +
    "\002\001\uff0e\000\002\001\uff3e\000\014\012\u0106\013\u0101" +
    "\014\u0102\015\u0104\020\u0105\001\uff40\000\002\001\uff37\000" +
    "\002\001\uff35\000\026\010\372\011\364\017\377\037\366" +
    "\077\371\100\365\103\367\104\374\106\373\107\376\001" +
    "\uff42\000\002\001\uff31\000\004\110\362\001\uff3a\000\010" +
    "\072\352\105\350\111\351\001\uff38\000\034\010\042\011" +
    "\071\016\307\021\311\042\312\066\306\067\010\075\335" +
    "\101\340\105\326\112\331\117\310\120\323\001\002\000" +
    "\002\001\uff11\000\002\001\uff36\000\002\001\uff0b\000\002" +
    "\001\uff63\000\032\010\042\011\071\016\307\021\311\042" +
    "\312\066\306\067\010\075\335\105\326\112\331\117\310" +
    "\120\323\001\002\000\002\001\uff0d\000\002\001\uff0c\000" +
    "\002\001\uff3c\000\004\076\346\001\uff07\000\002\001\uff09" +
    "\000\002\001\uff05\000\006\074\015\101\344\001\002\000" +
    "\032\010\042\011\071\016\307\021\311\042\312\066\306" +
    "\067\010\075\335\105\326\112\331\117\310\120\323\001" +
    "\002\000\002\001\uff0a\000\004\076\346\001\uff08\000\032" +
    "\010\042\011\071\016\307\021\311\042\312\066\306\067" +
    "\010\075\335\105\326\112\331\117\310\120\323\001\002" +
    "\000\002\001\uff06\000\032\010\042\011\071\016\307\021" +
    "\311\042\312\066\306\067\010\075\335\105\326\112\331" +
    "\117\310\120\323\001\002\000\002\001\uff2d\000\004\067" +
    "\010\001\002\000\002\001\uff26\000\006\074\015\101\360" +
    "\001\002\000\002\001\uff20\000\002\001\uff21\000\032\010" +
    "\042\011\071\016\307\021\311\042\312\066\306\067\010" +
    "\075\335\105\326\112\331\117\310\120\323\001\002\000" +
    "\002\001\uff27\000\002\001\uff22\000\026\016\307\021\311" +
    "\042\312\066\306\067\010\075\335\105\326\112\331\117" +
    "\310\120\323\001\002\000\002\001\uff39\000\002\001\ufefb" +
    "\000\002\001\ufef3\000\002\001\ufeee\000\002\001\ufeef\000" +
    "\032\010\042\011\071\016\307\021\311\042\312\066\306" +
    "\067\010\075\335\105\326\112\331\117\310\120\323\001" +
    "\002\000\002\001\ufef4\000\002\001\ufefc\000\002\001\ufef0" +
    "\000\002\001\ufef1\000\032\010\042\011\071\016\307\021" +
    "\311\042\312\066\306\067\010\075\335\105\326\112\331" +
    "\117\310\120\323\001\002\000\002\001\ufef2\000\002\001" +
    "\ufefa\000\014\012\u0106\013\u0101\014\u0102\015\u0104\020\u0105" +
    "\001\uff3f\000\002\001\ufef9\000\002\001\ufef6\000\032\010" +
    "\042\011\071\016\307\021\311\042\312\066\306\067\010" +
    "\075\335\105\326\112\331\117\310\120\323\001\002\000" +
    "\002\001\ufef5\000\002\001\ufef8\000\002\001\ufef7\000\002" +
    "\001\uff3d\000\010\010\372\011\364\017\377\001\uff41\000" +
    "\004\022\u010a\001\002\000\002\001\uff34\000\002\001\uff33" +
    "\000\032\010\042\011\071\016\307\021\311\042\312\066" +
    "\306\067\010\075\335\105\326\112\331\117\310\120\323" +
    "\001\002\000\002\001\uff24\000\002\001\uff57\000\004\073" +
    "\u0114\001\uff56\000\006\022\u0112\074\015\001\002\000\032" +
    "\010\042\011\071\016\307\021\311\042\312\066\306\067" +
    "\010\075\335\105\326\112\331\117\310\120\323\001\002" +
    "\000\002\001\uff59\000\002\001\uff58\000\032\010\042\011" +
    "\071\016\307\021\311\042\312\066\306\067\010\075\335" +
    "\105\326\112\331\117\310\120\323\001\002\000\004\073" +
    "\u0116\001\uff55\000\032\010\042\011\071\016\307\021\311" +
    "\042\312\066\306\067\010\075\335\105\326\112\331\117" +
    "\310\120\323\001\002\000\002\001\uff54\000\002\001\uff53" +
    "\000\032\010\042\011\071\016\307\021\311\042\312\066" +
    "\306\067\010\075\335\105\326\112\331\117\310\120\323" +
    "\001\002\000\002\001\uff5c\000\004\054\u011c\001\002\000" +
    "\026\005\231\006\242\031\252\034\266\035\257\050\243" +
    "\063\267\064\240\067\010\075\253\001\uff69\000\002\001" +
    "\uff67\000\004\026\u011f\001\uff7e\000\026\005\231\006\242" +
    "\031\252\034\266\035\257\050\243\063\267\064\240\067" +
    "\010\075\253\001\uff69\000\002\001\uff4c\000\002\001\uff66" +
    "\000\002\001\uff5b\000\002\001\uff60\000\004\070\u0125\001" +
    "\002\000\032\010\042\011\071\016\307\021\311\042\312" +
    "\066\306\067\010\075\335\105\326\112\331\117\310\120" +
    "\323\001\002\000\002\001\uff61\000\006\025\u012a\055\u0128" +
    "\001\002\000\002\001\uff5f\000\032\010\042\011\071\016" +
    "\307\021\311\042\312\066\306\067\010\075\335\105\326" +
    "\112\331\117\310\120\323\001\002\000\002\001\uff5e\000" +
    "\002\001\uff5d\000\002\001\uff62\000\026\005\231\006\242" +
    "\031\252\034\266\035\257\050\243\063\267\064\240\067" +
    "\010\075\253\001\uff69\000\002\001\uff4b\000\002\001\uff65" +
    "\000\026\005\231\006\242\031\252\034\266\035\257\050" +
    "\243\063\267\064\240\067\010\075\253\001\uff69\000\002" +
    "\001\uff4a\000\002\001\uff64\000\026\005\231\006\242\031" +
    "\252\034\266\035\257\050\243\063\267\064\240\067\010" +
    "\075\253\001\uff80\000\006\060\u0135\071\021\001\002\000" +
    "\032\010\042\011\071\016\307\021\311\042\312\066\306" +
    "\067\010\075\335\105\326\112\331\117\310\120\323\001" +
    "\002\000\002\001\uff4e\000\002\001\uff49\000\004\043\u0139" +
    "\001\002\000\016\010\042\011\071\066\045\067\010\075" +
    "\102\112\075\001\002\000\006\073\u0142\074\015\001\002" +
    "\000\006\027\u013f\071\u013d\001\002\000\002\001\uff47\000" +
    "\004\027\u0141\001\ufede\000\016\010\042\011\071\066\045" +
    "\067\010\075\102\112\075\001\002\000\002\001\uff51\000" +
    "\002\001\uff48\000\002\001\uff50\000\026\005\231\006\242" +
    "\031\252\034\266\035\257\050\243\063\267\064\240\067" +
    "\010\075\253\001\uff69\000\002\001\uff46\000\006\024\u0148" +
    "\074\015\001\002\000\002\001\uff30\000\010\072\352\105" +
    "\350\111\351\001\uff44\000\004\067\010\001\002\000\026" +
    "\005\231\006\242\031\252\034\266\035\257\050\243\063" +
    "\267\064\240\067\010\075\253\001\uff69\000\002\001\uff4d" +
    "\000\002\001\uff68\000\010\072\352\105\350\111\351\001" +
    "\uff45\000\004\073\u014d\001\uff84\000\046\004\077\010\042" +
    "\011\071\021\057\044\053\047\070\051\066\053\063\066" +
    "\045\067\054\075\102\102\064\111\061\112\075\113\073" +
    "\114\062\115\076\116\047\001\002\000\002\001\uff85\000" +
    "\002\001\uff88\000\004\021\u0152\001\002\000\002\001\uffa3" +
    "\000\012\033\223\045\216\062\u0158\067\014\001\002\000" +
    "\002\001\uff93\000\002\001\uff87\000\002\001\uff8e\000\002" +
    "\001\uff95\000\002\001\uff8f\000\004\067\014\001\002\000" +
    "\006\022\u0160\071\021\001\002\000\002\001\uff92\000\006" +
    "\073\u015e\074\015\001\002\000\002\001\uff96\000\002\001" +
    "\uff94\000\046\004\077\010\042\011\071\021\057\044\053" +
    "\047\070\051\066\053\063\066\045\067\054\075\102\102" +
    "\064\111\061\112\075\113\073\114\062\115\076\116\047" +
    "\001\002\000\002\001\uff91\000\002\001\uff98\000\012\033" +
    "\223\045\216\062\u0158\067\014\001\002\000\002\001\uff97" +
    "\000\006\073\u0164\074\015\001\002\000\046\004\077\010" +
    "\042\011\071\021\057\044\053\047\070\051\066\053\063" +
    "\066\045\067\054\075\102\102\064\111\061\112\075\113" +
    "\073\114\062\115\076\116\047\001\002\000\002\001\uff90" +
    "\000\004\021\u0152\001\002\000\004\073\u0168\001\002\000" +
    "\046\004\077\010\042\011\071\021\057\044\053\047\070" +
    "\051\066\053\063\066\045\067\054\075\102\102\064\111" +
    "\061\112\075\113\073\114\062\115\076\116\047\001\002" +
    "\000\002\001\uff86\000\012\003\023\032\u016b\041\024\052" +
    "\u016c\001\ufff5\000\002\001\uff9a\000\002\001\uff99\000\002" +
    "\001\uff9b\000\002\001\uff9c\000\002\001\uff8c\000\002\001" +
    "\uff8d\000\012\003\023\032\u016b\041\024\052\u016c\001\ufff5" +
    "\000\002\001\uff89\000\002\001\uff8b\000\002\001\uff83\000" +
    "\006\003\023\041\024\001\ufff5\000\002\001\uff8a\000\006" +
    "\003\u0178\067\014\001\uffdd\000\002\001\uffd8\000\006\073" +
    "\u017b\074\015\001\002\000\002\001\uffda\000\046\004\077" +
    "\010\042\011\071\021\057\044\053\047\070\051\066\053" +
    "\063\066\045\067\054\075\102\102\064\111\061\112\075" +
    "\113\073\114\062\115\076\116\047\001\002\000\004\071" +
    "\021\001\002\000\002\001\uffd9\000\004\071\021\001\002" +
    "\000\002\001\uffd7\000\002\001\uffdb\000\002\001\uffed\000" +
    "\004\077\u0186\001\002\000\006\003\u0181\067\010\001\ufff2" +
    "\000\002\001\uffef\000\002\001\ufff0\000\024\010\042\011" +
    "\071\016\u018a\021\u018c\042\312\066\306\067\010\075\335" +
    "\112\331\001\002\000\026\010\372\011\364\017\377\037" +
    "\366\077\371\100\365\103\367\104\374\106\373\107\376" +
    "\001\uff1f\000\004\110\u0199\001\uff17\000\002\001\uff15\000" +
    "\020\016\u018a\021\u018c\042\312\066\306\067\010\075\335" +
    "\112\331\001\002\000\002\001\uff18\000\024\010\042\011" +
    "\071\016\u018a\021\u018c\042\312\066\306\067\010\075\335" +
    "\112\331\001\002\000\002\001\uff13\000\004\071\021\001" +
    "\002\000\002\001\uff1b\000\014\012\u0106\013\u0101\014\u0102" +
    "\015\u0104\020\u0105\001\uff1d\000\024\010\042\011\071\016" +
    "\u018a\021\u018c\042\312\066\306\067\010\075\335\112\331" +
    "\001\002\000\002\001\uff19\000\024\010\042\011\071\016" +
    "\u018a\021\u018c\042\312\066\306\067\010\075\335\112\331" +
    "\001\002\000\002\001\uff1a\000\002\001\uffee\000\004\022" +
    "\u0197\001\002\000\002\001\uff14\000\002\001\uff12\000\020" +
    "\016\u018a\021\u018c\042\312\066\306\067\010\075\335\112" +
    "\331\001\002\000\002\001\uff16\000\024\010\042\011\071" +
    "\016\u018a\021\u018c\042\312\066\306\067\010\075\335\112" +
    "\331\001\002\000\024\010\042\011\071\016\u018a\021\u018c" +
    "\042\312\066\306\067\010\075\335\112\331\001\002\000" +
    "\014\012\u0106\013\u0101\014\u0102\015\u0104\020\u0105\001\uff1c" +
    "\000\010\010\372\011\364\017\377\001\uff1e\000\004\071" +
    "\021\001\002\000\002\001\uffec\000\002\001\ufff3\000\006" +
    "\071\021\074\015\001\002\000\004\075\253\001\002\000" +
    "\002\001\ufff8\000\002\001\ufff4\000\004\071\021\001\002" +
    "\000\002\001\ufff6\000\002\001\000" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u01a6\000\006\002\003\003\004\001\001\000\002\001" +
    "\001\000\004\164\021\001\001\000\004\143\006\001\001" +
    "\000\004\236\010\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\004\012\001\001\000\004\165\015\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\010\025\013\024\001\001\000\004\240\u01a5\001\001\000" +
    "\006\014\u01a1\015\u01a0\001\001\000\004\016\030\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\017\u0183\020" +
    "\u0182\143\u0181\001\001\000\004\103\031\001\001\000\004" +
    "\022\211\001\001\000\010\104\036\105\033\143\035\001" +
    "\001\000\002\001\001\000\004\242\206\001\001\000\002" +
    "\001\001\000\006\105\037\143\035\001\001\000\002\001" +
    "\001\000\042\021\043\055\047\106\071\110\055\111\066" +
    "\112\051\113\064\114\054\115\100\116\073\123\057\136" +
    "\102\140\045\141\050\143\042\162\077\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\115\203\116" +
    "\073\123\057\136\102\140\045\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\004\201\001" +
    "\001\000\002\001\001\000\006\142\200\143\177\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\004\124\124\123\125\122\126\121\001\001\000\002\001" +
    "\001\000\004\164\120\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\055\103\143\042\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\026\021\043\055\047\111\111\112\051\113\064\117\107" +
    "\120\110\121\105\143\106\162\077\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\165\112\001\001\000\002" +
    "\001\001\000\002\001\001\000\024\021\043\055\047\111" +
    "\111\112\051\113\064\120\117\121\105\143\106\162\077" +
    "\001\001\000\002\001\001\000\044\021\043\055\047\106" +
    "\115\110\055\111\066\112\051\113\064\114\054\115\100" +
    "\116\073\122\116\123\057\136\102\140\045\141\050\143" +
    "\042\162\077\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\164\165\001\001\000\004\165\015" +
    "\001\001\000\012\127\127\134\130\135\126\143\131\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\135\133\143\134\001\001\000" +
    "\002\001\001\000\002\001\001\000\022\021\141\055\047" +
    "\130\140\131\137\132\136\133\142\143\042\162\077\001" +
    "\001\000\004\165\147\001\001\000\002\001\001\000\004" +
    "\164\145\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\021\144\055\047\143\042\162\077\001\001\000\002" +
    "\001\001\000\020\021\141\055\047\131\146\132\136\133" +
    "\142\143\042\162\077\001\001\000\002\001\001\000\014" +
    "\021\141\055\047\133\162\143\042\162\077\001\001\000" +
    "\002\001\001\000\012\004\124\124\153\125\122\126\152" +
    "\001\001\000\002\001\001\000\004\164\155\001\001\000" +
    "\002\001\001\000\010\004\124\125\157\126\156\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\042\021\043\055\047" +
    "\106\164\110\055\111\066\112\051\113\064\114\054\115" +
    "\100\116\073\123\057\136\102\140\045\141\050\143\042" +
    "\162\077\001\001\000\002\001\001\000\010\004\124\125" +
    "\157\126\167\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\024\021\043\055" +
    "\047\111\111\112\051\113\064\121\173\137\174\143\106" +
    "\162\077\001\001\000\002\001\001\000\002\001\001\000" +
    "\044\021\043\055\047\106\115\110\055\111\066\112\051" +
    "\113\064\114\054\115\100\116\073\122\176\123\057\136" +
    "\102\140\045\141\050\143\042\162\077\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\165" +
    "\015\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\021\205\055\047\143\042\162\077\001\001\000\002\001" +
    "\001\000\004\164\207\001\001\000\002\001\001\000\010" +
    "\004\u0178\023\u0176\024\u0179\001\001\000\024\026\223\027" +
    "\224\030\220\031\221\032\212\033\214\035\216\226\217" +
    "\227\213\001\001\000\002\001\001\000\006\164\u0174\245" +
    "\u0165\001\001\000\004\164\u0170\001\001\000\004\143\u016f" +
    "\001\001\000\004\164\u0169\001\001\000\004\244\u014f\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\143\u014b" +
    "\001\001\000\004\237\227\001\001\000\004\164\225\001" +
    "\001\000\020\030\226\031\221\032\212\033\214\035\216" +
    "\226\217\227\213\001\001\000\002\001\001\000\006\025" +
    "\232\206\231\001\001\000\070\006\243\007\245\015\267" +
    "\063\263\067\261\077\234\143\253\167\275\170\260\171" +
    "\246\172\272\173\264\174\271\175\235\176\247\177\233" +
    "\200\236\201\250\202\274\203\270\204\254\205\240\206" +
    "\244\207\273\210\257\234\255\235\262\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\063\u0145" +
    "\067\261\077\234\143\u0144\216\u0143\001\001\000\002\001" +
    "\001\000\046\063\324\067\261\074\320\077\234\143\304" +
    "\152\317\153\326\154\314\155\333\156\327\162\332\211" +
    "\u0137\220\u0136\221\321\222\316\223\315\224\312\225\323" +
    "\001\001\000\004\246\u0132\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\143\u0122\151\u0123\001" +
    "\001\000\002\001\001\000\004\231\u0121\001\001\000\002" +
    "\001\001\000\002\001\001\000\046\063\324\067\261\074" +
    "\320\077\234\143\304\152\317\153\326\154\314\155\333" +
    "\156\327\162\332\217\u011a\220\313\221\321\222\316\223" +
    "\315\224\312\225\323\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\015\u0117\001\001\000\046" +
    "\063\324\067\261\074\320\077\234\143\304\152\317\153" +
    "\326\154\314\155\333\156\327\162\332\217\331\220\313" +
    "\221\321\222\316\223\315\224\312\225\323\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\164" +
    "\276\001\001\000\066\006\243\007\245\015\267\063\263" +
    "\067\261\077\234\143\253\170\300\171\246\172\272\173" +
    "\264\174\271\175\235\176\247\177\233\200\236\201\250" +
    "\202\274\203\270\204\254\205\240\206\244\207\273\210" +
    "\257\234\255\235\262\001\001\000\002\001\001\000\002" +
    "\001\001\000\056\006\243\007\245\063\263\067\261\077" +
    "\234\143\253\173\302\174\303\175\235\176\247\177\233" +
    "\200\236\201\250\202\274\203\270\204\254\205\240\206" +
    "\244\207\273\210\257\234\255\235\262\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\231\u010c\001\001\000" +
    "\002\001\001\000\030\063\324\067\261\074\320\077\234" +
    "\143\304\152\317\153\326\154\314\155\333\156\327\225" +
    "\u010a\001\001\000\002\001\001\000\044\063\324\067\261" +
    "\074\320\077\234\143\304\152\317\153\326\154\314\155" +
    "\333\156\327\162\332\220\u0108\221\321\222\316\223\315" +
    "\224\312\225\323\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\161\u0102\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\160\374\166\367\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\050\063\324\067" +
    "\261\074\320\075\341\076\336\077\234\143\304\152\317" +
    "\153\326\154\314\155\333\156\327\162\332\220\340\221" +
    "\321\222\316\223\315\224\312\225\323\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\036\063\324\067\261\074\320\077\234\143\304" +
    "\152\317\153\326\154\314\155\333\156\327\162\332\223" +
    "\335\224\312\225\323\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\165\342\001\001\000\046" +
    "\063\324\067\261\074\320\076\344\077\234\143\304\152" +
    "\317\153\326\154\314\155\333\156\327\162\332\220\340" +
    "\221\321\222\316\223\315\224\312\225\323\001\001\000" +
    "\002\001\001\000\002\001\001\000\044\063\324\067\261" +
    "\074\320\077\234\143\304\152\317\153\326\154\314\155" +
    "\333\156\327\162\332\220\346\221\321\222\316\223\315" +
    "\224\312\225\323\001\001\000\002\001\001\000\050\061" +
    "\353\062\355\063\324\067\261\074\320\077\234\143\304" +
    "\152\317\153\326\154\314\155\333\156\327\162\332\220" +
    "\354\221\321\222\316\223\315\224\312\225\323\001\001" +
    "\000\002\001\001\000\004\143\352\001\001\000\002\001" +
    "\001\000\004\165\356\001\001\000\002\001\001\000\002" +
    "\001\001\000\046\062\360\063\324\067\261\074\320\077" +
    "\234\143\304\152\317\153\326\154\314\155\333\156\327" +
    "\162\332\220\354\221\321\222\316\223\315\224\312\225" +
    "\323\001\001\000\002\001\001\000\002\001\001\000\032" +
    "\063\324\067\261\074\320\077\234\143\304\152\317\153" +
    "\326\154\314\155\333\156\327\224\362\225\323\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\042\063\324\067\261" +
    "\074\320\077\234\143\304\152\317\153\326\154\314\155" +
    "\333\156\327\162\332\221\u0107\222\316\223\315\224\312" +
    "\225\323\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\040\063\324\067\261" +
    "\074\320\077\234\143\304\152\317\153\326\154\314\155" +
    "\333\156\327\162\332\222\377\223\315\224\312\225\323" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\161" +
    "\u0102\001\001\000\002\001\001\000\002\001\001\000\036" +
    "\063\324\067\261\074\320\077\234\143\304\152\317\153" +
    "\326\154\314\155\333\156\327\162\332\223\u0106\224\312" +
    "\225\323\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\160\374\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\050\063\324\067\261\074\320\077\234\143\304\152\317" +
    "\153\326\154\314\155\333\156\327\162\332\220\u010e\221" +
    "\321\222\316\223\315\224\312\225\323\232\u010f\233\u010d" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\165\u0110\001\001\000\046\063\324\067\261" +
    "\074\320\077\234\143\304\152\317\153\326\154\314\155" +
    "\333\156\327\162\332\220\u010e\221\321\222\316\223\315" +
    "\224\312\225\323\233\u0112\001\001\000\002\001\001\000" +
    "\002\001\001\000\044\063\324\067\261\074\320\077\234" +
    "\143\304\152\317\153\326\154\314\155\333\156\327\162" +
    "\332\220\u0114\221\321\222\316\223\315\224\312\225\323" +
    "\001\001\000\002\001\001\000\044\063\324\067\261\074" +
    "\320\077\234\143\304\152\317\153\326\154\314\155\333" +
    "\156\327\162\332\220\u0116\221\321\222\316\223\315\224" +
    "\312\225\323\001\001\000\002\001\001\000\002\001\001" +
    "\000\044\063\324\067\261\074\320\077\234\143\304\152" +
    "\317\153\326\154\314\155\333\156\327\162\332\220\u0119" +
    "\221\321\222\316\223\315\224\312\225\323\001\001\000" +
    "\002\001\001\000\002\001\001\000\066\006\243\007\245" +
    "\015\267\063\263\067\261\077\234\143\253\170\u011c\171" +
    "\246\172\u011d\173\264\174\271\175\235\176\247\177\233" +
    "\200\236\201\250\202\274\203\270\204\254\205\240\206" +
    "\244\207\273\210\257\234\255\235\262\001\001\000\002" +
    "\001\001\000\002\001\001\000\064\006\243\007\245\015" +
    "\267\063\263\067\261\077\234\143\253\171\u0120\172\u011f" +
    "\173\264\174\271\175\235\176\247\177\233\200\236\201" +
    "\250\202\274\203\270\204\254\205\240\206\244\207\273" +
    "\210\257\234\255\235\262\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\046\063\324\067\261\074\320\077\234\143" +
    "\304\152\317\153\326\154\314\155\333\156\327\162\332" +
    "\214\u0126\220\u0125\221\321\222\316\223\315\224\312\225" +
    "\323\001\001\000\002\001\001\000\004\230\u0128\001\001" +
    "\000\002\001\001\000\046\063\324\067\261\074\320\077" +
    "\234\143\304\152\317\153\326\154\314\155\333\156\327" +
    "\162\332\215\u012b\220\u012a\221\321\222\316\223\315\224" +
    "\312\225\323\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\064\006\243\007\245\015\267\063" +
    "\263\067\261\077\234\143\253\171\u012e\172\u012d\173\264" +
    "\174\271\175\235\176\247\177\233\200\236\201\250\202" +
    "\274\203\270\204\254\205\240\206\244\207\273\210\257" +
    "\234\255\235\262\001\001\000\002\001\001\000\002\001" +
    "\001\000\064\006\243\007\245\015\267\063\263\067\261" +
    "\077\234\143\253\171\u0131\172\u0130\173\264\174\271\175" +
    "\235\176\247\177\233\200\236\201\250\202\274\203\270" +
    "\204\254\205\240\206\244\207\273\210\257\234\255\235" +
    "\262\001\001\000\002\001\001\000\002\001\001\000\070" +
    "\006\243\007\245\015\267\063\263\067\261\077\234\143" +
    "\253\167\u0133\170\260\171\246\172\272\173\264\174\271" +
    "\175\235\176\247\177\233\200\236\201\250\202\274\203" +
    "\270\204\254\205\240\206\244\207\273\210\257\234\255" +
    "\235\262\001\001\000\004\164\276\001\001\000\046\063" +
    "\324\067\261\074\320\077\234\143\304\152\317\153\326" +
    "\154\314\155\333\156\327\162\332\217\u0135\220\313\221" +
    "\321\222\316\223\315\224\312\225\323\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\021" +
    "\141\055\047\132\u0139\133\142\143\042\162\077\212\u013a" +
    "\213\u013b\001\001\000\004\165\147\001\001\000\004\164" +
    "\u013d\001\001\000\002\001\001\000\002\001\001\000\020" +
    "\021\141\055\047\132\u0139\133\142\143\042\162\077\213" +
    "\u013f\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\066\006\243\007\245\015\267\063\263\067" +
    "\261\077\234\143\253\170\u0142\171\246\172\272\173\264" +
    "\174\271\175\235\176\247\177\233\200\236\201\250\202" +
    "\274\203\270\204\254\205\240\206\244\207\273\210\257" +
    "\234\255\235\262\001\001\000\002\001\001\000\004\165" +
    "\u0146\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\063\u014a\067\261\077\234\143\u0144\001\001\000\064\006" +
    "\243\007\245\015\267\063\263\067\261\077\234\143\253" +
    "\171\u0149\172\u0148\173\264\174\271\175\235\176\247\177" +
    "\233\200\236\201\250\202\274\203\270\204\254\205\240" +
    "\206\244\207\273\210\257\234\255\235\262\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\044\021\043\055\047\106\u014d\107\u014e\110" +
    "\055\111\066\112\051\113\064\114\054\115\100\116\073" +
    "\123\057\136\102\140\045\141\050\143\042\162\077\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\040\u0150" +
    "\001\001\000\002\001\001\000\030\004\u015a\033\u0154\035" +
    "\u0156\041\u0158\042\u015b\043\u0155\044\u015c\045\u0152\046\u0159" +
    "\226\217\227\u0153\001\001\000\002\001\001\000\004\245" +
    "\u0165\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\004\u0162\001\001\000\004\164\u0160\001" +
    "\001\000\002\001\001\000\004\165\015\001\001\000\002" +
    "\001\001\000\002\001\001\000\042\021\043\055\047\106" +
    "\u015e\110\055\111\066\112\051\113\064\114\054\115\100" +
    "\116\073\123\057\136\102\140\045\141\050\143\042\162" +
    "\077\001\001\000\002\001\001\000\002\001\001\000\026" +
    "\004\u015a\033\u0154\035\u0156\042\u0161\043\u0155\044\u015c\045" +
    "\u0152\046\u0159\226\217\227\u0153\001\001\000\002\001\001" +
    "\000\004\165\015\001\001\000\042\021\043\055\047\106" +
    "\u0164\110\055\111\066\112\051\113\064\114\054\115\100" +
    "\116\073\123\057\136\102\140\045\141\050\143\042\162" +
    "\077\001\001\000\002\001\001\000\004\040\u0166\001\001" +
    "\000\002\001\001\000\044\021\043\055\047\106\u014d\107" +
    "\u0168\110\055\111\066\112\051\113\064\114\054\115\100" +
    "\116\073\123\057\136\102\140\045\141\050\143\042\162" +
    "\077\001\001\000\002\001\001\000\012\010\u016e\013\024" +
    "\036\u016c\037\u016d\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\010\u0173\013\024\034\u0171\037" +
    "\u0172\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\010\u0173\013\024\034\u0175\001\001\000" +
    "\002\001\001\000\006\004\u0178\024\u017f\001\001\000\004" +
    "\243\u017d\001\001\000\004\165\015\001\001\000\002\001" +
    "\001\000\042\021\043\055\047\106\u017b\110\055\111\066" +
    "\112\051\113\064\114\054\115\100\116\073\123\057\136" +
    "\102\140\045\141\050\143\042\162\077\001\001\000\004" +
    "\164\u017c\001\001\000\002\001\001\000\004\164\u017e\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\241\u019e" +
    "\001\001\000\002\001\001\000\006\017\u0184\143\u0181\001" +
    "\001\000\002\001\001\000\002\001\001\000\032\047\u018d" +
    "\050\u0186\051\u018f\052\u018e\053\u018a\054\u0187\143\u0188\152" +
    "\u018c\153\326\154\314\155\333\162\u0190\001\001\000\006" +
    "\160\u019b\166\u019a\001\001\000\002\001\001\000\002\001" +
    "\001\000\016\054\u0197\143\u0188\152\u018c\153\326\154\314" +
    "\155\333\001\001\000\002\001\001\000\032\047\u0195\050" +
    "\u0186\051\u018f\052\u018e\053\u018a\054\u0187\143\u0188\152\u018c" +
    "\153\326\154\314\155\333\162\u0190\001\001\000\002\001" +
    "\001\000\004\164\u0194\001\001\000\002\001\001\000\004" +
    "\161\u0192\001\001\000\024\052\u0191\053\u018a\054\u0187\143" +
    "\u0188\152\u018c\153\326\154\314\155\333\162\u0190\001\001" +
    "\000\002\001\001\000\024\052\u0193\053\u018a\054\u0187\143" +
    "\u0188\152\u018c\153\326\154\314\155\333\162\u0190\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\020\053\u0199\054\u0187" +
    "\143\u0188\152\u018c\153\326\154\314\155\333\001\001\000" +
    "\002\001\001\000\030\050\u019d\051\u018f\052\u018e\053\u018a" +
    "\054\u0187\143\u0188\152\u018c\153\326\154\314\155\333\162" +
    "\u0190\001\001\000\026\051\u019c\052\u018e\053\u018a\054\u0187" +
    "\143\u0188\152\u018c\153\326\154\314\155\333\162\u0190\001" +
    "\001\000\004\161\u0192\001\001\000\004\160\u019b\001\001" +
    "\000\004\164\u019f\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\164\u01a3\165\u01a2\001\001\000\004\015\u01a4" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\164" +
    "\u01a6\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	TabelaDeSimbolos.inicializa();
	Tipo.criaTipos();


	/* os labels servem para ajudar na gerenciar destino de laços (labels) */
	//List<Integer> labels = new ArrayList<Integer>();
	
	/* variavel auxiliar para manipulacao de labels */
	//int label = 0;

    }


	public static int errors = 0;
    public static StringBuffer code = new StringBuffer();

	public void report_error(String message, Object info){
		StringBuilder m = new StringBuilder("Error");
   		errors++; 
          
        m.append(" : "+message);
   
        System.err.println("Error "+ MainTest.scanner.current_lexeme() + " : Sintantic error");
		System.err.println(m + "" + (info instanceof String ? info : " "));
	}
	
	/* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	public void sem_error(String lexeme, String message) {
		errors ++;
		System.err.println("Error in line "+ MainTest.scanner.current_line() + " : Semantic error");
      	System.err.println("==> " + message + ": "+ lexeme + "\n");
  	}
  	
  	public void sem_error(String message) {
		errors ++;
		System.err.println("Error "+ MainTest.scanner.current_lexeme() + " : Semantic error");
      	System.err.println("==> " + message +"\n");
  	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Parser$actions {


	class Exp {
	  public Tipo tipo;
	  public String code;
	  public boolean isConstant;

	  Exp(Tipo t, String code) {
		this(t, code, false);
	  }
	  
	  Exp(Tipo t, String code, boolean cte) {
		tipo = t;
		this.code = code;
		isConstant = cte;
	  }
	}

	class Reg {
		
		 
		public String id;
		public String val;
		
		Reg(String id) {
			this(id,"");
		}
		
		Reg(String id, String val) {
			this.id = id;
			this.val = val;
		}
	
	}
	
	public static String assembOp(String pascOper) {
		if(pascOper.equals("-")) {
			return "SUB";
		}
		else if(pascOper.equals("+")) {
			return "ADD";
		}
		else if(pascOper.equals("*")) {
			return "MUL";
		}
		else if(pascOper.equals("/") || pascOper.toLowerCase().equals("div")) {
			return "DIV";
		}
		return "";
	}
	
	/* listas auxiliares para gerenciar registradores */
	List<Reg> argRegs = new ArrayList<Reg> ();
	
	/* pesquisa um registrador argumento dado seu valor */
	public Reg getArgReg(String val) {
		for(Reg reg : argRegs) {
			if(reg.val.equals(val))
				return reg;
		}
		return null;
	}
	
	/* lista para gerenciar destino de laços (labels) */
	List<Integer> labels = new ArrayList<Integer>();
	
	/* variavel auxiliar para manipulacao de labels */
	int label = 0;

  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 292: // comma ::= COMMA 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("comma",115, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 291: // semicolon ::= SEMICOLON 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("semicolon",114, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 290: // string ::= STRING 
            {
              String RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("string",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 289: // number ::= unsigned_real 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("number",62, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 288: // number ::= unsigned_integer 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("number",62, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 287: // module ::= constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("module",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 286: // element_list ::= expression 
            {
              List<String> RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("element_list",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 285: // element_list ::= element_list comma expression 
            {
              List<String> RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("element_list",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 284: // non_string ::= REALNUMBER 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_string",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 283: // non_string ::= identifier 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_string",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 282: // non_string ::= DIGSEQ 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_string",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 281: // sign ::= MINUS 
            {
              String RESULT =null;
		int menosleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int menosright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String menos = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = menos; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sign",112, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 280: // sign ::= PLUS 
            {
              String RESULT =null;
		int maisleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int maisright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String mais = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = mais; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sign",112, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 279: // constant ::= CHARACTER_STRING 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 278: // constant ::= sign non_string 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 277: // constant ::= non_string 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 276: // identifier ::= IDENTIFIER 
            {
              String RESULT =null;
		int xleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int xright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String x = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = x; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier",97, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 275: // relational_operator ::= IN 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",116, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 274: // relational_operator ::= GE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",116, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 273: // relational_operator ::= LE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",116, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 272: // relational_operator ::= GT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",116, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 271: // relational_operator ::= LT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",116, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 270: // relational_operator ::= NOTEQUAL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",116, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 269: // relational_operator ::= EQUAL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relational_operator",116, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 268: // mulop ::= AND 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = a; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mulop",111, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 267: // mulop ::= MOD 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = m; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mulop",111, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 266: // mulop ::= DIV 
            {
              String RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String d = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = d; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mulop",111, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 265: // mulop ::= SLASH 
            {
              String RESULT =null;
		int slleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int slright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String sl = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = sl; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mulop",111, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 264: // mulop ::= STAR 
            {
              String RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = s; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("mulop",111, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 263: // addition_operator ::= OR 
            {
              String RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String o = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = o; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("addition_operator",110, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 262: // addition_operator ::= MINUS 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = m; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("addition_operator",110, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 261: // addition_operator ::= PLUS 
            {
              String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = p; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("addition_operator",110, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 260: // record_variable ::= variable 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_variable",54, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 259: // array_variable ::= variable 
            {
              String RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("array_variable",100, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 258: // bound_identifier ::= identifier 
            {
              String RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("bound_identifier",99, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 257: // constant_identifier ::= identifier 
            {
              String RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant_identifier",98, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 256: // field_identifier ::= identifier 
            {
              String RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("field_identifier",102, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 255: // variable_identifier ::= identifier 
            {
              String RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable_identifier",101, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 254: // pointer_variable ::= variable 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("pointer_variable",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 253: // referenced_variable ::= pointer_variable UPARROW 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("referenced_variable",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 252: // member_designator ::= expression 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("member_designator",60, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 251: // member_designator ::= member_designator DOTDOT expression 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("member_designator",60, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 250: // member_designator_list ::= member_designator 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("member_designator_list",59, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 249: // member_designator_list ::= member_designator_list comma member_designator 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("member_designator_list",59, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 248: // set_constructor ::= LBRAC RBRAC 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("set_constructor",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 247: // set_constructor ::= LBRAC member_designator_list RBRAC 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("set_constructor",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 246: // unsigned_real ::= REALNUMBER 
            {
              Exp RESULT =null;
		int rnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object rn = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(Tipo.getTipo(Tipo.REAL), ""+rn); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unsigned_real",107, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 245: // unsigned_integer ::= DIGSEQ 
            {
              Exp RESULT =null;
		int dsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int dsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ds = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(Tipo.getTipo(Tipo.INTEGER), ""+ds); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unsigned_integer",106, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 244: // unsigned_number ::= unsigned_real 
            {
              Exp RESULT =null;
		int urleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int urright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp ur = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(ur.tipo, ur.code); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unsigned_number",105, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 243: // unsigned_number ::= unsigned_integer 
            {
              Exp RESULT =null;
		int uileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int uiright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp ui = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(ui.tipo, ui.code); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unsigned_number",105, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 242: // unsigned_constant ::= NIL 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",104, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // unsigned_constant ::= CHARACTER_STRING 
            {
              Exp RESULT =null;
		int csleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int csright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String cs = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
   						  RESULT = (cs.length() == 3) ? new Exp(Tipo.getTipo(Tipo.CHAR), cs) : 
														new Exp(Tipo.getTipo(Tipo.STRING), cs); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",104, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // unsigned_constant ::= unsigned_number 
            {
              Exp RESULT =null;
		int unleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int unright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp un = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(un.tipo, un.code); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",104, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // cprimary ::= NOT cprimary 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cprimary",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // cprimary ::= unsigned_constant 
            {
              Tipo RESULT =null;
		int ucleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ucright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp uc = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT  = uc.tipo; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cprimary",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // cprimary ::= LPAREN cexpression RPAREN 
            {
              Tipo RESULT =null;
		int celeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ceright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Tipo ce = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = ce; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cprimary",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // cprimary ::= identifier 
            {
              Tipo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
   				    Simbolo simbolo = null;
   					if((simbolo = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   						parser.sem_error(id, "nome desconhecido");
   						RESULT = Tipo.getTipo(Tipo.ERRO);
   					} else {
   						RESULT = simbolo.getTipo(); 
   					}
   				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cprimary",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // cexponentiation ::= cprimary STARSTAR cexponentiation 
            {
              Tipo RESULT =null;
		int cpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int cpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Tipo cp = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 RESULT = cp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cexponentiation",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // cexponentiation ::= cprimary 
            {
              Tipo RESULT =null;
		int cpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo cp = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = cp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cexponentiation",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // cfactor ::= cexponentiation 
            {
              Tipo RESULT =null;
		int celeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ceright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo ce = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ce; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cfactor",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // cfactor ::= sign cfactor 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cfactor",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // cterm ::= cterm mulop cfactor 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cterm",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // cterm ::= cfactor 
            {
              Tipo RESULT =null;
		int cfactorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cfactorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo cfactor = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = cfactor; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cterm",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // csimple_expression ::= csimple_expression addition_operator cterm 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("csimple_expression",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // csimple_expression ::= cterm 
            {
              Tipo RESULT =null;
		int ctermleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ctermright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo cterm = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = cterm; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("csimple_expression",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // cexpression ::= csimple_expression relational_operator csimple_expression 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cexpression",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // cexpression ::= csimple_expression 
            {
              Tipo RESULT =null;
		int csimpleleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int csimpleright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo csimple = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = csimple; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cexpression",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // index_expression ::= expression 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("index_expression",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // index_expression_list ::= index_expression 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("index_expression_list",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // index_expression_list ::= index_expression_list comma index_expression 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("index_expression_list",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // file_buffer ::= file_variable UPARROW 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("file_buffer",64, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // function_designator ::= identifier params 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int prsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int prsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		List<Exp> prs = (List<Exp>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   							Simbolo t = null;
   							if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								parser.sem_error(id, "nome desconhecido");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "?");
   							}
   							else {
								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoDosParametros().size() != prs.size()) {
   									parser.sem_error(id, "esperava " + tf.getTipoDosParametros().size() + " parametros");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   								else {
   									for(int i = 0; i < prs.size(); i++) {
   										if(! tf.getTipoDosParametros().get(i).getVal().equals(prs.get(i).tipo.getVal())) {
   											parser.sem_error(id, "Tipos dos parametros passados sao imcompativeis com os parametros de");
   											RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   										} else {
											Reg argReg = argRegs.get(i);
											parser.code.append("\t LD "+argReg.id+" , "+prs.get(i).code +"\n"); 
   										}
   									}
   									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   									RESULT = new Exp(tf.getTipoDoRetorno(), "V0");
   								}
   							}
   						
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_designator",108, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // set ::= LBRAC element_list RBRAC 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("set",63, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // field_designator ::= variable DOT identifier 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("field_designator",61, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // indexed_variable ::= variable LBRAC index_expression_list RBRAC 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("indexed_variable",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // component_variable ::= file_buffer 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("component_variable",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // component_variable ::= field_designator 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("component_variable",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // component_variable ::= indexed_variable 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("component_variable",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // entire_variable ::= field_identifier 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("entire_variable",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // entire_variable ::= variable_identifier 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("entire_variable",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // variable ::= variable UPARROW 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // variable ::= field_designator 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // variable ::= indexed_variable 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // variable ::= identifier 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
					Simbolo t = null;
   					if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   						parser.sem_error(id, "nome de variavel desconhecido/nao definido");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					} else {
   						RESULT = new Exp(t.getTipo(), id); 
					}
   					
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // primary ::= FALSE 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), "0"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("primary",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // primary ::= TRUE 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), "1"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("primary",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // primary ::= NOT primary 
            {
              Exp RESULT =null;
		int prleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int prright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp pr = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 if(! pr.tipo.getVal().equals("boolean")) {
             		if(! pr.tipo.getVal().equals("error")) {
             			parser.sem_error(pr.tipo.getVal(), "Esse operador nao foi definido para o tipo da expressao usada");
             		}
             		RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
             	}
             	else {
					parser.code.append("\t LD R0 , "+pr.code+"\n");
					parser.code.append("\t NOT R0\n");
					pr.code = "R0";
             		RESULT = pr;
             	}
             
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("primary",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // primary ::= LPAREN expression RPAREN 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
					if(getArgReg("temp") == null) {
						parser.code.append("\t LD R2 , "+exp.code+"\n");
						argRegs.add(new Reg("R2", "temp"));
						exp.code = "R2";
					}
					RESULT = exp; 
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("primary",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // primary ::= set_constructor 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("primary",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // primary ::= function_designator 
            {
              Exp RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp fd = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(fd.tipo, fd.code); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("primary",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // primary ::= unsigned_constant 
            {
              Exp RESULT =null;
		int ucleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ucright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp uc = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(uc.tipo, "#"+uc.code, true); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("primary",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // primary ::= variable 
            {
              Exp RESULT =null;
		int valeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int varight = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp va = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
   						if(va.tipo instanceof TipoFuncao) {
							TipoFuncao tf = (TipoFuncao) va.tipo;
   							if( tf.getTipoDosParametros().size() != 0) {
   								parser.sem_error("", "esperava "+tf.getTipoDosParametros().size()
   											+" parametros para essa funcao");
								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							} else {
								parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   								parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   								parser.code.append("\t BR "+va.code+"\n"); 
   								parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								RESULT = new Exp(va.tipo,"V0");
   							}
   						} else {
							if(! TabelaDeSimbolos.escopoCorrente.isRoot()) {
									Reg arg = getArgReg(va.code);
									if(arg != null) {
										va.code = arg.id;
										//Se a variable_access for um argumento, carregar em regs diferentes
										parser.code.append("\t LD R"+va.code.charAt(1)+" , "+va.code +"\n"); 
										RESULT =  new Exp(va.tipo, "R"+va.code.charAt(1));
									}
									else {
										parser.code.append("\t LD R0 , "+va.code +"\n");
										RESULT =  new Exp(va.tipo, "R0"); 
									}
							}
							else {
								parser.code.append("\t LD R0 , "+va.code +"\n");
								RESULT =  new Exp(va.tipo, "R0"); 
							}
						}
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("primary",147, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // exponentiation ::= primary STARSTAR exponentiation 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exponentiation",146, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // exponentiation ::= primary 
            {
              Exp RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp p = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
							RESULT = new Exp(p.tipo, p.code, p.isConstant); 
						
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("exponentiation",146, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // factor ::= exponentiation 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(exp.tipo, exp.code, exp.isConstant); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",145, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // factor ::= sign factor 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String sn = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp f = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
   				if(sn.toLowerCase().equals("-")) {
   					if(! (f.tipo.getVal().equals("integer") || f.tipo.getVal().equals("real"))) {
   						parser.sem_error(f.tipo.getVal(), "Esse operador nao foi definido para o tipo da expressao usada");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					}
   					else {
   						RESULT = f;
   					}
   				}
   				else if(sn.toLowerCase().equals("+")) {
   					if(! (f.tipo.getVal().equals("integer") || f.tipo.getVal().equals("real")
   							|| f.tipo.getVal().equals("string") || f.tipo.getVal().equals("char"))) {
   						parser.sem_error(f.tipo.getVal(), "Esse operador nao foi definido para o tipo da expressao usada");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					}
   					else {
   						RESULT = f;
   					}
   				}
   			
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",145, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // term ::= term mulop factor 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int adleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int adright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String ad = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int teleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   		if(ad != null) {
			   if(ad.toLowerCase().equals("and")) {
				   if(!(se.tipo.getVal().equals("boolean") && te.tipo.getVal().equals("boolean"))) {
					   parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "O operador AND nao funciona com esses tipos, eh um operador logico  ");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
					} else {
						if(! "R1".equals(se.code))
							parser.code.append("\t LD R1 , "+se.code+"\n");
						se.code = "R1";
						parser.code.append("\t AND "+se.code+" , "+se.code+" , "+te.code+"\n");
   						RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), se.code);
					}
   				} else if(ad.toLowerCase().equals("*") || ad.toLowerCase().equals("/")) {
					   if((se.tipo.getVal().equals("integer") || se.tipo.getVal().equals("real")) && 
					   	(te.tipo.getVal().equals("integer") || te.tipo.getVal().equals("real"))) {
						   String op = assembOp(ad.toLowerCase());
							if(se.isConstant) {
								parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
								se.code = "R1";
							} else {
								parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
							}
   							RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), se.code);
   						} else {
   							parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "Esse operador "+ad+" nao foi definido para esses tipos ");
   							RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   						}
				} else if(ad.toLowerCase().equals("mod") || ad.toLowerCase().equals("div")) {
					if(se.tipo.getVal().equals("integer") && te.tipo.getVal().equals("integer")) {
						String op = assembOp(ad.toLowerCase());
						if(se.isConstant) {
							parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
							se.code = "R1";
						} else {
							parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
						}
   						
						RESULT = new Exp(Tipo.getTipo(Tipo.INTEGER), se.code);
   					} else {
						   parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "Esse operador "+ad+" nao foi definido para esses tipos ");
						   RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   					}
				}
 			}
	
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",144, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // term ::= factor 
            {
              Exp RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp f = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(f.tipo, f.code, f.isConstant); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",144, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // simple_expression ::= simple_expression addition_operator term 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int adleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int adright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String ad = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int teleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   		if(ad != null) {
   			if(ad.toLowerCase().equals("or")) {
   				if(!(se.tipo.getVal().equals("boolean") && te.tipo.getVal().equals("boolean"))) {
   					parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "O operador OR nao funciona com esses tipos, eh um operador logico ");
   					RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   				} else {
					if(! "R1".equals(se.code))
						parser.code.append("\t LD R1 , "+se.code+"\n");
					se.code = "R1";
					parser.code.append("\t OR "+se.code+" , "+se.code+" , "+te.code+"\n");
   					RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), se.code);
   				}
   			} else if(ad.toLowerCase().equals("-") || ad.toLowerCase().equals("+")) {
   				if((se.tipo.getVal().equals("integer") || se.tipo.getVal().equals("real")) &&
   					 (te.tipo.getVal().equals("integer") || te.tipo.getVal().equals("real"))) {
					String op = assembOp(ad.toLowerCase());
					if(se.isConstant) {
						parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
						se.code = "R1";
					} else {
						parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
					}
				RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), se.code);
   			} else if((se.tipo.getVal().equals("char") || se.tipo.getVal().equals("string")) &&
   				  (te.tipo.getVal().equals("char") || te.tipo.getVal().equals("string"))) {
   				  RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), "?");
   			} else {
   				parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "Esse operador: "+ad+" nao foi definido para esses tipos ");
   				RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   			}
   		}
   	}

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expression",143, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // simple_expression ::= term 
            {
              Exp RESULT =null;
		int teleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(te.tipo, te.code, te.isConstant); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expression",143, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // expression ::= simple_expression relational_operator simple_expression 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), ""); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression",142, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // expression ::= simple_expression 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new Exp(se.tipo, se.code); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression",142, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // boolean_expression ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
   							if(exp != null) {
   								if(! exp.tipo.getVal().equals("boolean")) {
   									if(! exp.tipo.getVal().equals("error"))
   										parser.sem_error(exp.tipo.getVal(), "nao foi possivel converter para boolean");
   							 		RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   								else {
   									RESULT = new Exp(exp.tipo, exp.code);
   								}
   							}

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_expression",141, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // record_variable_list ::= variable 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_variable_list",140, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // record_variable_list ::= record_variable_list comma variable 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_variable_list",140, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // case_list_element ::= case_constant_list COLON statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_list_element",137, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // case_list_element_list ::= case_list_element 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_list_element_list",136, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // case_list_element_list ::= case_list_element_list semicolon case_list_element 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_list_element_list",136, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // case_index ::= expression 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_index",135, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // closed_for_statement ::= for_designator DO structured_statement 
            {
              Object RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<String> fd = (List<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
		parser.code.append("\t LD R3 , "+fd.get(0)+"\n");
		if(fd.get(1) != null && fd.get(1).toLowerCase().equals("to")) {
			parser.code.append("\t ADD R3 , R3 , #1\n");
		} else if(fd.get(1) != null && fd.get(1).toLowerCase().equals("downto")) {
			parser.code.append("\t SUB R3 , R3 , #1\n");
		}
		parser.code.append("\t ST "+fd.get(0)+" , R3\n");
		parser.code.append("\t BR "+fd.get(2)+"\n");
		parser.code.append(fd.get(3)+":\n");
	
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("closed_for_statement",130, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // closed_while_statement ::= while_designator DO structured_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("closed_while_statement",128, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // closed_if_statement ::= IF boolean_expression THEN structured_statement ELSE structured_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("closed_if_statement",126, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // closed_with_statement ::= WITH record_variable_list DO structured_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("closed_with_statement",124, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // repeat_statement ::= REPEAT NT$8 statement_sequence UNTIL boolean_expression 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int beleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int beright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp be = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		parser.code.append("\t LD R0"+" , "+be.code+"\n");
		parser.code.append("\t SUB R1 , R0 , 1\n");
		parser.code.append("\t BEQZ R1 , $L"+label+"\n");
		label --;
	
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("repeat_statement",133, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // NT$8 ::= 
            {
              Object RESULT =null;

		labels.add(labels.size()+1);
		label = labels.size();
		parser.code.append("$L"+labels.size()+":\n");
	
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$8",164, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // case_statement ::= CASE case_index OF case_list_element_list SEMICOLON END 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_statement",134, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // case_statement ::= CASE case_index OF case_list_element_list END 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_statement",134, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // compound_statement ::= BEGIN statement_sequence END 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compound_statement",132, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // goto_statement ::= GOTO label 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("goto_statement",131, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // actual_parameter ::= expression COLON expression COLON expression 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",153, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // actual_parameter ::= expression COLON expression 
            {
              Exp RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",153, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // actual_parameter ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",153, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // actual_parameter_list ::= actual_parameter 
            {
              List<Exp> RESULT =null;
		int apleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int apright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp ap = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   								List<Exp> l = new ArrayList<Exp>();
   								l.add(ap);
   								RESULT = l;
   							
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameter_list",152, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // actual_parameter_list ::= actual_parameter_list comma actual_parameter 
            {
              List<Exp> RESULT =null;
		int aplleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int aplright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<Exp> apl = (List<Exp>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int apleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int apright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp ap = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   								apl.add(ap);
   								RESULT = apl;
   							
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameter_list",152, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // params ::= LPAREN actual_parameter_list RPAREN 
            {
              List<Exp> RESULT =null;
		int aplleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int aplright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Exp> apl = (List<Exp>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = apl; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("params",151, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // procedure_statement ::= identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   							Simbolo t = null;
   							 if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								 parser.sem_error(id, "nome desconhecido");
   								
   							 }
   							 else {
   								
   								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoDosParametros().size() != 0) {
   									parser.sem_error(id, "esperava " + tf.getTipoDosParametros().size() + " parametros");
   									
   								} else {
									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								}
   							 }
   							
   						
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_statement",155, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // procedure_statement ::= identifier params 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int prsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int prsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		List<Exp> prs = (List<Exp>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   							
   							 Simbolo t = null;
   							 if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								 parser.sem_error(id, "nome desconhecido");
   								
   							 }
   							 else {
   								
   								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoDosParametros().size() != prs.size()) {
   									parser.sem_error(id, "esperava " + tf.getTipoDosParametros().size() + " parametros");
   									
   								}
   								else {
   									for(int i = 0; i < prs.size(); i++) {
   										if(! tf.getTipoDosParametros().get(i).getVal().equals(prs.get(i).tipo.getVal())) {
   											parser.sem_error(id, "Tipos dos parametros passados sao imcompativeis com os parametros de");
   											
   										}
   										Reg argReg = new Reg("A"+i);
   										parser.code.append("\t LD "+argReg.id+" , "+prs.get(i).code+"\n"); 
   									}
   									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								}
   							 }
   							
   						
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_statement",155, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // assignment_statement ::= variable ASSIGNMENT expression 
            {
              Tipo RESULT =null;
		int tvaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tvaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Exp tva = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int texpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int texpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp texp = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
   							if( tva.tipo instanceof TipoFuncao ) {
								if(TabelaDeSimbolos.escopoCorrente.isRoot()) {
									parser.sem_error(tva.code, "retorno fora do escopo da funcao ");
									RESULT = Tipo.getTipo(Tipo.ERRO);
								}
								else {
								    TipoFuncao tf = (TipoFuncao) tva.tipo;
								    Tipo rt = tf.getTipoDoRetorno();
								    if(! rt.getVal().equals(texp.tipo.getVal())) {
									 if(! rt.getVal().equals("erro") && ! rt.getVal().equals("erro")) {
										 if(! (rt.getVal().equals("real") && texp.tipo.getVal().equals("integer"))) {
											 parser.sem_error(rt.getVal(), "incompatibilidade de tipos - nao foi possivel converter "+ texp.tipo.getVal() + " para ");
											 RESULT = Tipo.getTipo(Tipo.ERRO);
										 }
									 }
									}
									else {
										tva.code = "V0";
										parser.code.append("\t LD "+tva.code+" , "+texp.code +"\n");
										RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
									}
								}
							}
   							else if(! tva.tipo.getVal().equals(texp.tipo.getVal())) {
   								if(! texp.tipo.getVal().equals("erro") && ! tva.tipo.getVal().equals("erro")) {
   									if(! (tva.tipo.getVal().equals("real") && texp.tipo.getVal().equals("integer"))) {
   										parser.sem_error(tva.tipo.getVal(), "incompatibilidade de tipos - nao foi possivel converter "+ texp.tipo.getVal() + " para ");
   										RESULT = Tipo.getTipo(Tipo.ERRO);
   									}
   									else {
										parser.code.append("\t ST "+tva.code+" , "+texp.code +"\n");
   										RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
   									}
   								}
   						   }
   						   else {
								parser.code.append("\t ST "+tva.code+" , "+texp.code +"\n");
   						        RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
   						   }
   						
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assignment_statement",154, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // final_value ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("final_value",139, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // direction ::= DOWNTO 
            {
              String RESULT =null;
		 RESULT = "downTo"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("direction",150, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // direction ::= TO 
            {
              String RESULT =null;
		 RESULT = "to"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("direction",150, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // control_variable ::= identifier 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
   							Simbolo t = null;
   							if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								parser.sem_error(id, "nome nao definido");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							} else if(t.getTipo().getVal().equals("char") || t.getTipo().getVal().equals("integer")){
   								RESULT = new Exp(t.getTipo(), id); 
   							}
   							else {
   								parser.sem_error("char ou integer", "O tipo de controle da variavel '"+id+"' ");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							}

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("control_variable",103, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // initial_value ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("initial_value",138, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // for_designator ::= FOR control_variable ASSIGNMENT initial_value direction final_value 
            {
              List<String> RESULT =null;
		int cvleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int cvright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Exp cv = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int ivleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ivright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Exp iv = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int dirleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int dirright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String dir = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int fvleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fvright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Exp fv = (Exp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		String lbl1 = "", lblFalse = "";
		if(!cv.tipo.getVal().equals("error")) {
			if(!cv.tipo.getVal().equals(iv.tipo.getVal())) {
				parser.sem_error(cv.tipo.getVal(), "O tpo do valor inicial deveria ser ");
			} else if(!cv.tipo.getVal().equals(fv.tipo.getVal())) {
				parser.sem_error(cv.tipo.getVal(), "O tipo do valor final deveria ser ");
			} else {
				parser.code.append("\t ST "+cv.code+" , "+iv.code+"\n");
				labels.add(labels.size()+1);
				lbl1 = "$L"+labels.size();
				parser.code.append(lbl1+":\n");
				parser.code.append("\t LD R4 , "+fv.code+"\n");
				parser.code.append("\t LD R3 , "+cv.code+"\n");
				parser.code.append("\t SUB R0 , R3 , R4\n");
				labels.add(labels.size()+1);
				lblFalse = "$L"+labels.size();
				if(dir != null && dir.toLowerCase().equals("to"))
					parser.code.append("\t BGTZ R0 , "+lblFalse+"\n");
				else if(dir != null && dir.toLowerCase().equals("downto"))
					parser.code.append("\t BLTZ R0 , "+lblFalse+"\n");
			}
		}
		List<String> forArgs = new ArrayList<String>();
		forArgs.add(cv.code);
		forArgs.add(dir);
		forArgs.add(lbl1);
		forArgs.add(lblFalse);
		RESULT = forArgs;
	
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("for_designator",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // while_designator ::= WHILE boolean_expression 
            {
              List<String> RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("while_designator",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // open_for_statement ::= for_designator DO simple_statement 
            {
              Object RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<String> fd = (List<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
		parser.code.append("\t LD R3 , "+fd.get(0)+"\n");
		if(fd.get(1) != null && fd.get(1).toLowerCase().equals("to")) {
			parser.code.append("\t ADD R3 , R3 , #1\n");
		} else if(fd.get(1) != null && fd.get(1).toLowerCase().equals("downto")) {
			parser.code.append("\t SUB R3 , R3 , #1\n");
		}
        parser.code.append("\t ST "+fd.get(0)+" , R3\n");
        parser.code.append("\t BR "+fd.get(2)+"\n");
        parser.code.append(fd.get(3)+":\n");
	
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("open_for_statement",129, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // open_while_statement ::= while_designator DO simple_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("open_while_statement",127, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // open_if_statement ::= IF boolean_expression THEN structured_statement ELSE simple_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("open_if_statement",125, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // open_if_statement ::= IF boolean_expression THEN statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("open_if_statement",125, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // open_with_statement ::= WITH record_variable_list DO simple_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("open_with_statement",123, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // non_labeled_structured_statement ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // non_labeled_structured_statement ::= closed_for_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // non_labeled_structured_statement ::= closed_while_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // non_labeled_structured_statement ::= closed_if_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // non_labeled_structured_statement ::= closed_with_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // non_labeled_structured_statement ::= repeat_statement 
            {
              Object RESULT =null;
		
									   labels.add(labels.size()+1);
									   parser.code.append("$L"+labels.size()+":\n");
									
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // non_labeled_structured_statement ::= case_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // non_labeled_structured_statement ::= compound_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // non_labeled_structured_statement ::= goto_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // non_labeled_structured_statement ::= procedure_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // non_labeled_structured_statement ::= assignment_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_structured_statement",122, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // non_labeled_simple_statement ::= open_for_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_simple_statement",121, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // non_labeled_simple_statement ::= open_while_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_simple_statement",121, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // non_labeled_simple_statement ::= open_if_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_simple_statement",121, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // non_labeled_simple_statement ::= open_with_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("non_labeled_simple_statement",121, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // structured_statement ::= non_labeled_structured_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("structured_statement",120, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // structured_statement ::= label COLON non_labeled_structured_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("structured_statement",120, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // simple_statement ::= non_labeled_simple_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_statement",119, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // simple_statement ::= label COLON non_labeled_simple_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_statement",119, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // compound_statement ::= BEGIN statement_sequence END 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("compound_statement",132, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // statement_part ::= compound_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement_part",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // statement ::= structured_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement",118, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // statement ::= simple_statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement",118, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // statement_sequence ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement_sequence",117, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // statement_sequence ::= statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement_sequence",117, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // statement_sequence ::= statement_sequence semicolon statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement_sequence",117, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // function_block ::= block 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_block",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // function_identification ::= FUNCTION identifier 
            {
              String RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
					if(! TabelaDeSimbolos.inserir(id.toLowerCase(), new Simbolo(id, new TipoFuncao(Tipo.getTipo(Tipo.TIPO_VOID))))) {
                            parser.sem_error(id, "nome duplicado");
                            RESULT = null;
                    }
                    else {
						RESULT = id;
					} 
					
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_identification",149, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // result_type ::= type_denoter 
            {
              Tipo RESULT =null;
		int tdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = td; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("result_type",69, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // function_heading ::= function_identification NT$7 formal_parameter_list COLON result_type 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int fileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int firight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		String fi = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int fplleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int fplright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<Tipo> fpl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo rt = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   							
   							if(fi != null) {
								Simbolo s = TabelaDeSimbolos.get(fi.toLowerCase());
								TipoFuncao t = (TipoFuncao) s.getTipo();
								t.setTipoDoRetorno(rt);
								t.addParamTipo(fpl);
							}
                             
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_heading",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // NT$7 ::= 
            {
              Object RESULT =null;
		int fileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int firight = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String fi = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

						   		TabelaDeSimbolos.push();
								parser.code.append(fi+": \n");
							
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$7",163, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // function_heading ::= FUNCTION identifier COLON result_type 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo rt = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   							if(! TabelaDeSimbolos.inserir(id.toLowerCase(), new Simbolo(id, new TipoFuncao(rt)))) {
                            	parser.sem_error(id, "nome dulicado");
                            } else {
								TabelaDeSimbolos.push();								
								parser.code.append(id+": \n");
							} 
   						
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_heading",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // function_declaration ::= function_heading semicolon function_block 
            {
              Object RESULT =null;
		 
						   	  parser.code.append("\t BR *0(SP) \n");                              
                              TabelaDeSimbolos.pop();
	            		 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_declaration",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // function_declaration ::= function_identification semicolon function_block 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_declaration",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // function_declaration ::= function_heading semicolon directive 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_declaration",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // procedure_block ::= block 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_block",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // procedure_identification ::= PROCEDURE identifier 
            {
              String RESULT =null;
		int identleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int identright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String ident = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
									
   									if(! TabelaDeSimbolos.inserir(ident.toLowerCase(), new Simbolo(ident, new TipoFuncao(Tipo.getTipo(Tipo.TIPO_VOID))))) {
                            			parser.sem_error(ident, "nome duplicado");
                            			RESULT = "";
                            		}
                            		else {
                            			RESULT = ident;
                            		}
                        		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_identification",148, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // functional_parameter_specification ::= function_heading 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("functional_parameter_specification",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // procedural_parameter_specification ::= procedure_heading 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedural_parameter_specification",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // variable_parameter_specification ::= VAR identifier_list COLON type_denoter 
            {
              List<Tipo> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
								/* para facilitar, consideramos que as duas formas recebem parâmetros */
										 
   									    List<Tipo> l = new ArrayList<Tipo>();
   									    int i = 0;
   										for(String id : il) {
                            				if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td))) {
                            					parser.sem_error(id, "nome duplicado");
                            				}
                            				l.add(td);                           				
										
                            			}
                            			RESULT = l;
   								
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable_parameter_specification",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // value_parameter_specification ::= identifier_list COLON type_denoter 
            {
              List<Tipo> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   								    List<Tipo> l = new ArrayList<Tipo>();
   									for(String id : il) {
                            			if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td))) {
                            				parser.sem_error(id, "nome duplicado");
                            			}
                            			l.add(td);
                            			
                            		}
                            		RESULT = l;
   								
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value_parameter_specification",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // formal_parameter_section ::= functional_parameter_specification 
            {
              List<Tipo> RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // formal_parameter_section ::= procedural_parameter_specification 
            {
              List<Tipo> RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // formal_parameter_section ::= variable_parameter_specification 
            {
              List<Tipo> RESULT =null;
		int varpsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int varpsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		List<Tipo> varps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = varps; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // formal_parameter_section ::= value_parameter_specification 
            {
              List<Tipo> RESULT =null;
		int vpsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vpsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		List<Tipo> vps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = vps; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // formal_parameter_section_list ::= formal_parameter_section 
            {
              List<Tipo> RESULT =null;
		int fpsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fpsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		List<Tipo> fps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
						List<Tipo> l = new ArrayList<Tipo>();
						for(Tipo t : fps) {
							l.add(t);
						} 
						RESULT = l;
					
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section_list",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // formal_parameter_section_list ::= formal_parameter_section_list semicolon formal_parameter_section 
            {
              List<Tipo> RESULT =null;
		int fpslleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int fpslright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<Tipo> fpsl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int fpsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fpsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		List<Tipo> fps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
					for(Tipo t : fps) {
						fpsl.add(t);
					} 
					RESULT = fpsl;
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section_list",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // formal_parameter_list ::= LPAREN formal_parameter_section_list RPAREN 
            {
              List<Tipo> RESULT =null;
		int fpslleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fpslright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Tipo> fpsl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = fpsl; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_list",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // directive ::= EXTERNAL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("directive",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // directive ::= FORWARD 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("directive",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // procedure_declaration ::= procedure_heading semicolon procedure_block 
            {
              Object RESULT =null;
		 
			parser.code.append("\t BR *0(SP) \n");
			TabelaDeSimbolos.pop();
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_declaration",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // procedure_declaration ::= procedure_heading semicolon directive 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_declaration",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // proc_or_func_declaration ::= function_declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // proc_or_func_declaration ::= procedure_declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // proc_or_func_declaration_list ::= proc_or_func_declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration_list",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // proc_or_func_declaration_list ::= proc_or_func_declaration_list semicolon proc_or_func_declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration_list",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // procedure_and_function_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_and_function_declaration_part",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // procedure_and_function_declaration_part ::= proc_or_func_declaration_list semicolon 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_and_function_declaration_part",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // procedure_heading ::= procedure_identification NT$6 formal_parameter_list 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int pileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int piright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int fplleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fplright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		List<Tipo> fpl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 Simbolo s = TabelaDeSimbolos.get(pi.toLowerCase());
                            if(s != null) {
								TipoFuncao t = (TipoFuncao) s.getTipo();
								t.addParamTipo(fpl);
							}
                         
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_heading",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // NT$6 ::= 
            {
              Object RESULT =null;
		int pileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int piright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
 
							TabelaDeSimbolos.push();
							parser.code.append(pi+": \n");
						
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$6",162, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // procedure_heading ::= procedure_identification 
            {
              Object RESULT =null;
		int pileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int piright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
							TabelaDeSimbolos.push();
							parser.code.append(pi+": \n");
						
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_heading",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // domain_type ::= identifier 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("domain_type",96, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // new_pointer_type ::= UPARROW domain_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("new_pointer_type",95, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // file_type ::= PFILE OF component_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("file_type",94, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // base_type ::= ordinal_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("base_type",93, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // set_type ::= SET OF base_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("set_type",92, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // tag_type ::= identifier 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("tag_type",91, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // tag_field ::= identifier 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("tag_field",90, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // case_constant ::= constant DOTDOT constant 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_constant",89, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // case_constant ::= constant 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_constant",89, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // case_constant_list ::= case_constant 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_constant_list",88, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // case_constant_list ::= case_constant_list comma case_constant 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("case_constant_list",88, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // variant ::= case_constant_list COLON LPAREN variant_part RPAREN 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant",87, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // variant ::= case_constant_list COLON LPAREN record_section_list semicolon variant_part RPAREN 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant",87, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // variant ::= case_constant_list COLON LPAREN record_section_list RPAREN 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant",87, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // variant_list ::= variant 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant_list",86, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // variant_list ::= variant_list semicolon variant 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant_list",86, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // variant_selector ::= tag_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant_selector",85, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // variant_selector ::= tag_field COLON tag_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant_selector",85, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // variant_part ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant_part",84, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // variant_part ::= CASE variant_selector OF variant_list 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant_part",84, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // variant_part ::= CASE variant_selector OF variant_list semicolon 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variant_part",84, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // record_section ::= identifier_list COLON type_denoter 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_section",83, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // record_section_list ::= record_section 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_section_list",82, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // record_section_list ::= record_section_list semicolon record_section 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_section_list",82, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // record_type ::= RECORD variant_part END 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_type",81, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // record_type ::= RECORD record_section_list semicolon variant_part END 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_type",81, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // record_type ::= RECORD record_section_list END 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_type",81, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // component_type ::= type_denoter 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("component_type",80, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // ordinal_type ::= identifier 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ordinal_type",79, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // ordinal_type ::= new_ordinal_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ordinal_type",79, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // index_type ::= ordinal_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("index_type",78, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // index_list ::= index_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("index_list",77, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // index_list ::= index_list comma index_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("index_list",77, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // array_type ::= ARRAY LBRAC index_list RBRAC OF component_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("array_type",76, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // structured_type ::= file_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("structured_type",75, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // structured_type ::= set_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("structured_type",75, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // structured_type ::= record_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("structured_type",75, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // structured_type ::= array_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("structured_type",75, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // new_structured_type ::= PACKED structured_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("new_structured_type",74, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // new_structured_type ::= structured_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("new_structured_type",74, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // subrange_type ::= constant DOTDOT constant 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("subrange_type",73, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // enumerated_type ::= LPAREN identifier_list RPAREN 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("enumerated_type",72, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // new_ordinal_type ::= subrange_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("new_ordinal_type",71, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // new_ordinal_type ::= enumerated_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("new_ordinal_type",71, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // new_type ::= new_pointer_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("new_type",70, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // new_type ::= new_structured_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("new_type",70, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // new_type ::= new_ordinal_type 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("new_type",70, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // identifier_list ::= IDENTIFIER 
            {
              List<String> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		   List<String> il = new ArrayList<String>();
   					 						il.add(id.toLowerCase());
						RESULT = il; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_list",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // identifier_list ::= identifier_list comma IDENTIFIER 
            {
              List<String> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 il.add(id.toLowerCase()); RESULT = il; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_list",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // variable_declaration ::= error NT$5 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable_declaration",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$5 ::= 
            {
              Object RESULT =null;
 parser.report_error("","era esperado ';' antes do token"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$5",161, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // variable_declaration ::= identifier_list COLON type_denoter semicolon 
            {
              Object RESULT =null;
		int listIdentleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int listIdentright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		List<String> listIdent = (List<String>)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int typleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int typright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Tipo typ = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                	for(String id : listIdent) {
                            if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, typ))) {
                            			parser.sem_error(id, "nome duplicado");
                            		}
                            	}
   							
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable_declaration",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // variable_declaration_list ::= variable_declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_list",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // variable_declaration_list ::= variable_declaration_list variable_declaration 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_list",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // variable_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_part",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // variable_declaration_part ::= VAR variable_declaration_list 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_part",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // type_denoter ::= BOOLEAN 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.BOOLEAN); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_denoter",68, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // type_denoter ::= REAL 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.REAL); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_denoter",68, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // type_denoter ::= CHAR 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.CHAR); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_denoter",68, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // type_denoter ::= INTEGER 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.INTEGER); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_denoter",68, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // type_denoter ::= STRING 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.STRING); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_denoter",68, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // type_denoter ::= new_type 
            {
              Tipo RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_denoter",68, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // type_denoter ::= IDENTIFIER 
            {
              Tipo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
   						Simbolo simbolo = null;
   						if((simbolo = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   							parser.sem_error(id, "Tipo nao definido");
   							RESULT = Tipo.getTipo(Tipo.ERRO);
   						} else {
   							RESULT = simbolo.getTipo(); 
   						}
   					
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_denoter",68, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // type_definition ::= error NT$4 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_definition",67, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$4 ::= 
            {
              Object RESULT =null;
 parser.report_error("","era esperado ';' antes do token"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$4",160, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // type_definition ::= identifier EQUAL type_denoter semicolon 
            {
              Object RESULT =null;
		int identleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int identright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String ident = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int typleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int typright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Tipo typ = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 if(! TabelaDeSimbolos.inserirVariavel(ident.toLowerCase(), new Simbolo(ident, typ, true))) {
                            	parser.sem_error(ident, "nome duplicado");
                       } 
                     
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_definition",67, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // type_definition_list ::= type_definition 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_definition_list",66, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // type_definition_list ::= type_definition_list type_definition 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_definition_list",66, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // type_definition_part ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_definition_part",65, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // type_definition_part ::= TYPE type_definition_list 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_definition_part",65, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // constant_definition ::= error NT$3 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant_definition",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NT$3 ::= 
            {
              Object RESULT =null;
 parser.report_error("","era esperado ';' antes do token"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$3",159, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // constant_definition ::= identifier EQUAL cexpression semicolon 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Tipo exp = (Tipo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 if(!TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, exp, true))) {
                            	parser.sem_error(id, "Nome duplicado");
                            }  
                         
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant_definition",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // constant_list ::= constant_definition 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant_list",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // constant_list ::= constant_list constant_definition 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant_list",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // constant_definition_part ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant_definition_part",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // constant_definition_part ::= CONST constant_list 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant_definition_part",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // label_list ::= label 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("label_list",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // label_list ::= label_list comma label 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("label_list",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // label_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // label_declaration_part ::= error NT$2 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // NT$2 ::= 
            {
              Object RESULT =null;
 parser.report_error("","era esperado ';' antes do token"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$2",158, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // label_declaration_part ::= LABEL label_list semicolon 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // declaration_part ::= label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaration_part",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // block ::= label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part NT$1 statement_part 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("block",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // NT$1 ::= 
            {
              Object RESULT =null;
 
				 	if(TabelaDeSimbolos.escopoCorrente.isRoot()) { 
						parser.code.append("main: \n");
				 	} 
			   	
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$1",157, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // label ::= DIGSEQ 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("label",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // program_heading ::= PROGRAM identifier NT$0 LPAREN identifier_list RPAREN 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("program_heading",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$0 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

	 		parser.code.append("##  Codigo assembly simples para "+id+".\n");
			parser.code.append("\t LD SP, #stackStart \n");
			parser.code.append("\t BR main \n");
	 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$0",156, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program_heading ::= PROGRAM identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			parser.code.append("##  Codigo assembly simples para "+id+".\n");
			parser.code.append("\t LD SP, #stackStart \n");
			parser.code.append("\t BR main \n");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("program_heading",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // program ::= program_heading semicolon block DOT 
            {
              Object RESULT =null;
		 parser.code.append("\t HALT \n\n"); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

